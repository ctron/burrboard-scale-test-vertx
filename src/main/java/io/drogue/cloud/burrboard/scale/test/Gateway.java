package io.drogue.cloud.burrboard.scale.test;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.stream.IntStream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import io.netty.handler.codec.mqtt.MqttQoS;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.mqtt.MqttClient;
import io.vertx.mqtt.MqttClientOptions;

public class Gateway {

    private static final Logger log = LoggerFactory.getLogger(Gateway.class);

    private final Vertx vertx;
    private final MqttClient client;
    private final Configuration config;
    private final Device[] devices;
    private final Timer tickDurationTimer;
    private final Counter updatesCounter;
    private final Duration period;

    private volatile boolean running;
    private Long scheduledTick;
    private Instant lastTick;

    public Gateway(final Vertx vertx, final Configuration config, final MeterRegistry registry, int start, int amount) {

        log.info("Creating gateway - start: {}, amount: {}", start, amount);

        this.vertx = vertx;

        this.period = Duration.ofMillis(1000 / 30);
        this.lastTick = Instant.now();

        this.tickDurationTimer = registry.timer("tickDurationTimer");
        this.updatesCounter = registry.counter("updates");

        var options = new MqttClientOptions()
                .setAutoKeepAlive(true)
                .setCleanSession(true)
                .setAutoGeneratedClientId(true);

        if (config.getPassword() != null) {
            options
                    .setUsername(config.getFullGatewayDevice())
                    .setPassword(config.getPassword());
        }

        if (config.isTls()) {
            options
                    .setSsl(true);

            if (config.isInsecure()) {
                options.setTrustAll(true);
            }
        }

        this.client = MqttClient.create(vertx, options);

        this.client.closeHandler(x -> closed(null));
        this.config = config;
        this.devices = IntStream
                .range(start, start + amount)
                .mapToObj(i -> new Device(String.format("simulated%05d", i)))
                .toArray(Device[]::new);
    }

    public Future<?> start() {
        this.running = true;
        reconnect();
        return Future.succeededFuture();
    }

    public Future<?> stop() {
        this.running = false;
        if (this.scheduledTick != null) {
            this.vertx.cancelTimer(this.scheduledTick);
        }
        this.client.disconnect();
        return Promise.promise().future();
    }

    private void reconnect() {
        if (!this.running) {
            return;
        }

        log.info("Connecting...");
        this.client
                .connect(this.config.getPort(), this.config.getHost())
                .onComplete(x -> this.doTick())
                .onFailure(this::closed);
    }

    private void closed(Throwable e) {
        log.info("Connection failed", e);
        if (this.running) {
            this.vertx.setTimer(1_000, x -> this.reconnect());
        }
        if (this.scheduledTick != null) {
            this.vertx.cancelTimer(this.scheduledTick);
        }
    }

    public void tick() {
        this.vertx.getOrCreateContext().runOnContext(x -> this.doTick());
    }

    private void doTick() {
        if (!this.running) {
            return;
        }

        var now = Instant.now();
        tickDevices()
                .onSuccess(x -> {
                    updateStats(Duration.between(now, Instant.now()));
                })
                .onFailure(err -> {
                    log.info("Failed to tick devices", err);
                })
                .onComplete(x -> {
                    scheduleTick();
                })
        ;
    }

    private void scheduleTick() {
        var now = Instant.now();
        var nextTick = this.lastTick.plus(this.period);
        var delay = Duration.between(now, nextTick);
        this.lastTick = nextTick;
        if (delay.toMillis() < 1) {
            delay = Duration.ofMillis(1);
        }

        log.debug("Last tick: {}, next tick: {}, delay: {}", this.lastTick, nextTick, delay.toMillis());

        this.scheduledTick = this.vertx.setTimer(delay.toMillis(), x -> {
            tick();
        });
    }

    @SuppressWarnings("rawtypes")
    private Future<?> tickDevices() {
        var ctx = new GatewayContext() {
            @Override
            public Future<Integer> sendAs(String device, String subject, MqttQoS qos, Buffer payload) {
                final var topic = String.format("%s/%s", subject, device);
                return Gateway.this.publish(topic, payload, qos);
            }
        };
        var futures = new ArrayList<Future>(this.devices.length);
        for (var device : this.devices) {
            futures.add(device.tick(ctx).onComplete(x -> {
                this.updatesCounter.increment(1);
            }));
        }

        return CompositeFuture.all(futures);
    }

    private Future<Integer> publish(String topic, Buffer payload, MqttQoS qos) {
        if (this.client.isConnected()) {
            return this.client.publish(topic, payload, qos, false, false);
        } else {
            return Future.failedFuture("Not connected");
        }
    }

    private void updateStats(Duration duration) {
        this.tickDurationTimer.record(duration);
    }

}
